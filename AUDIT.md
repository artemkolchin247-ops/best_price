# Подробный аудит приложения `best_price`

## 1) Резюме

Приложение имеет рабочую модульную структуру (ingestion → forecasting → optimization → UI) и заметный прогресс в сторону production-ready поведения: валидации входа, защитные режимы, диагностические логи, покрытие тестами базовых сценариев. При этом в текущем состоянии есть критичные разрывы между контрактами модулей и тестов, а также технические риски (отладочные `print`, широкие `except`, неполная строгость валидаций), которые могут приводить к тихим ошибкам и нестабильной эксплуатации.

**Итоговая оценка зрелости (субъективно): 6.5/10.**

---


## Статус после итераций по boundary-диагностике (обновление)

После исходного аудита в проект внесены ключевые улучшения по интерпретируемости оптимизации:
- Добавлен двухуровневый сигнал границ оптимума: `is_boundary_search` (край поисковой сетки) и `is_boundary_history` (близость к историческим границам).
- В `best_info` добавлен `boundary_meta` с диагностическими полями (`search_min/search_max`, `hist_min_before/hist_max_before`, `tol`).
- В UI разделены предупреждения по двум типам boundary-рисков и добавлены рекомендации по действиям.
- Добавлен совместимый fallback вызова оптимизатора для сред со старой сигнатурой функции.
- Тесты оптимизатора расширены до проверок ключевых сценариев boundary-флагов.

Это закрывает часть ранее отмеченных рисков по несогласованности интерпретации “граничного” решения.

---

## 2) Архитектура и поток данных

### Наблюдаемая схема
1. **Загрузка данных** из Excel через `ExcelIngestor` (`src/ingestion/excel_parser.py`).
2. **Подготовка/валидация и обучение** модели спроса в `SalesForecaster` (`src/models/sales_forecast.py`).
3. **Оптимизация цены** перебором в `optimize_price` (`src/optimizer/bruteforce.py`).
4. **Визуализация и управление сценарием** через Streamlit UI (`ui/app.py`).

### Сильные стороны по архитектуре
- Хорошее функциональное разбиение по доменам (`ingestion`, `models`, `optimizer`, `fincore`).
- В модели реализованы защитные режимы и диагностика качества данных.
- В ingestion есть авто-маппинг колонок и базовая нормализация.

---

## 3) Критичные и высокие риски

## CRITICAL-1: Несоответствие контрактов optimizer ↔ tests
- В `optimize_price` результат содержит колонку `price_before_spp`.
- Но тест ожидает `price_before`.
- Это означает, что контракт API не синхронизирован между кодом и тестами; в реальном окружении это риск скрытых ошибок интеграции.

**Факты:**
- `src/optimizer/bruteforce.py`: формирует `price_before_spp` в результирующем DataFrame.
- `tests/test_optimizer.py`: проверяет наличие `price_before`.

**Риск:** падения/неверные ожидания на интеграции и в аналитических отчётах.

**Рекомендация:** унифицировать контракт (либо везде `price_before_spp`, либо везде `price_before`) и зафиксировать это в README + тестах.

## HIGH-1: «Мягкая» валидация обязательных колонок в ingestion
- `_basic_validations` пишет ошибку про отсутствующие колонки в `report`, но `load_files` всё равно возвращает DataFrame.
- Без строгого gate можно передавать частично невалидные данные дальше по pipeline.

**Риск:** дальнейшие модули обучаются/оптимизируют на некорректном наборе данных.

**Рекомендация:** добавить режим strict (например `raise_on_errors=True`) и по умолчанию прерывать pipeline при отсутствии критичных полей.

## HIGH-2: Широкие `except` и подавление ошибок
- В `ui/app.py` при `sf.fit(...)` используется `except Exception` с немедленным fallback.
- В `sales_forecast.py` есть места с `except:` при приведении типов/обработке столбцов.

**Риск:** настоящие ошибки (логические/данные/регрессии) маскируются как «нормальный fallback», затрудняя диагностику.

**Рекомендация:** ловить только ожидаемые типы исключений и логировать traceback в structured logs.

## HIGH-3: Отладочные `print` в core-модулях
- В `src/models/sales_forecast.py` есть многочисленные `print("DEBUG ...")` в вычислительной логике.

**Риск:** шум в логах, снижение наблюдаемости, ухудшение интеграции с централизованным логированием.

**Рекомендация:** заменить на стандартный `logging` (уровни DEBUG/INFO/WARN), добавить переключатель уровня из UI/config.

---

## 4) Средние риски

## MEDIUM-1: Неявное объединение SKU при отсутствии колонки
- В ingestion при отсутствии `sku` создаётся `"Default SKU"` для всех строк.

**Риск:** смешивание разнородных товаров в одну серию и искажение эластичности/оптимума.

**Рекомендация:** сделать это поведение явно опциональным и показывать пользователю блокирующее предупреждение.

## MEDIUM-2: Несогласованность тестового контура
- Тесты запускаются и для `scripts/test_*.py`, что смешивает unit-тесты и вспомогательные скрипты.

**Риск:** нестабильный CI и ложные падения.

**Рекомендация:** изолировать пути в `pytest.ini` (`testpaths = tests`) и переименовать скрипты, не являющиеся unit-тестами.

## MEDIUM-3: Нет явной фиксации зависимостей
- В репозитории не видно lock/requirements с пиннингом версий.

**Риск:** нерепродуцируемость окружения, различия поведения между средами.

**Рекомендация:** добавить `requirements.txt`/`pyproject.toml` с фиксированными версиями + CI matrix.

---

## 5) Сильные стороны реализации

- Реализованы финансовые функции (`commission`, `vat`, `margin`, `profit`) в отдельном модуле с простыми и прозрачными формулами.
- В модели спроса присутствуют несколько алгоритмов (LogLog, RF, Poisson) и механизм выбора.
- В UI предусмотрены диагностические панели и понятный пользовательский поток.
- Есть набор тестов для ingestion/model/optimizer/calculations (хотя он требует доведения до воспроизводимого запуска).

---

## 6) Операционный аудит (запуск проверок)

Была выполнена попытка запуска тестов:
- `pytest -q`

Результат: ошибки на этапе коллекции из-за отсутствия `pandas` в окружении, поэтому функциональная корректность автоматически не подтверждена в рамках текущей среды.

---

## 7) Приоритизированный план улучшений

### P0 (срочно)
1. Синхронизировать контракт колонок цены (`price_before` vs `price_before_spp`) в коде, тестах и документации.
2. Ввести строгий режим валидации ingestion с остановкой при критичных ошибках.
3. Убрать широкие `except` в критических путях обучения/оптимизации.

### P1
4. Перевести debug-вывод с `print` на `logging` с уровнями.
5. Изолировать unit-тесты от скриптов проверки в `pytest` конфиге.
6. Зафиксировать зависимости и добавить воспроизводимую команду bootstrap.

### P2
7. Усилить data contracts (например через pydantic/typed schemas) на границе ingestion → model → optimizer.
8. Добавить smoke E2E-тест для минимального сценария через synthetic dataset.

---

## 8) Заключение

Проект уже содержит полезную доменную логику и фундамент для практического использования, но для устойчивой эксплуатации нужен фокус на **контракты данных**, **строгость ошибок** и **воспроизводимость окружения**. После закрытия P0-блока приложение станет значительно надежнее как для аналитиков, так и для интеграции в CI/CD и production-процессы.
